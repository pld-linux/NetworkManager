diff -urN NetworkManager-0.6.5.orig/configure.in NetworkManager-0.6.5/configure.in
--- NetworkManager-0.6.5.orig/configure.in	2007-07-23 19:44:13.000000000 +0200
+++ NetworkManager-0.6.5/configure.in	2007-07-23 20:09:37.000000000 +0200
@@ -72,7 +72,7 @@
 	exit 1
 else
 	case $with_distro in
-		redhat|suse|gentoo|debian|slackware|arch) ;;
+		redhat|suse|gentoo|debian|slackware|arch|pld) ;;
 		*)
 			echo "Your distribution (${with_distro}) is not yet supported!  (patches welcome)"
 			exit 1
@@ -85,6 +85,7 @@
 AM_CONDITIONAL(TARGET_DEBIAN, test x"$with_distro" = xdebian)
 AM_CONDITIONAL(TARGET_SLACKWARE, test x"$with_distro" = xslackware)
 AM_CONDITIONAL(TARGET_ARCH, test x"$with_distro" = xarch)
+AM_CONDITIONAL(TARGET_PLD, test x"$with_distro" = xpld)
 
 AC_MSG_CHECKING([for wireless-tools >= 28pre9])
 AC_TRY_COMPILE([#include <iwlib.h>],
diff -urN NetworkManager-0.6.5.orig/src/backends/Makefile.am NetworkManager-0.6.5/src/backends/Makefile.am
--- NetworkManager-0.6.5.orig/src/backends/Makefile.am	2007-07-23 19:44:13.000000000 +0200
+++ NetworkManager-0.6.5/src/backends/Makefile.am	2007-07-23 20:12:37.000000000 +0200
@@ -42,6 +42,12 @@
 libnmbackend_la_SOURCES +=	NetworkManagerArch.c
 endif
 
+if TARGET_PLD
+libnmbackend_la_SOURCES += NetworkManagerPLD.c \
+	shvar.c \
+	shvar.h
+endif
+
 libnmbackend_la_LIBADD = $(DBUS_LIBS) $(GTHREAD_LIBS)
 libnmbackend_la_CPPFLAGS =	$(DBUS_CFLAGS)				\
 					$(GTHREAD_CFLAGS)				\
diff -urN NetworkManager-0.6.5.orig/src/backends/NetworkManagerPLD.c NetworkManager-0.6.5/src/backends/NetworkManagerPLD.c
--- NetworkManager-0.6.5.orig/src/backends/NetworkManagerPLD.c	1970-01-01 01:00:00.000000000 +0100
+++ NetworkManager-0.6.5/src/backends/NetworkManagerPLD.c	2007-10-29 21:38:41.000000000 +0100
@@ -0,0 +1,694 @@
+/* NetworkManager -- Network link manager
+ *
+ * Narayan Newton <narayan_newton@yahoo.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * (C) Copyright 2004 RedHat, Inc.
+ * (C) Copyright 2004 Narayan Newton
+ * (C) Copyright 2005 wrobell <wrobell@pld-linux.org>
+ * (C) Copyright 2005 Patryk Zawadzki <patrys@pld-linux.org>
+ * (C) Copyright 2007 Marcin Banasiak <megabajt@pld-linux.org>
+ */
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <signal.h>
+#include "NetworkManagerSystem.h"
+#include "NetworkManagerUtils.h"
+#include "nm-device.h"
+#include "nm-device-802-3-ethernet.h"
+#include "nm-device-802-11-wireless.h"
+#include "nm-utils.h"
+#include "shvar.h"
+
+/*
+ * nm_system_init
+ *
+ * Initializes the distribution-specific system backend
+ *
+ */
+void nm_system_init (void)
+{
+	/* Kill any dhclients lying around */
+        nm_system_kill_all_dhcp_daemons();
+}
+
+/*
+ * nm_system_device_flush_routes
+ *
+ * Flush all routes associated with a network device
+ *
+ */
+void nm_system_device_flush_routes (NMDevice *dev)
+{
+	g_return_if_fail (dev != NULL);
+
+	/* Not really applicable for test devices */
+	if (nm_device_is_test_device (dev))
+		return;
+
+	nm_system_device_flush_routes_with_iface (nm_device_get_iface (dev));
+}
+
+/*
+ * nm_system_device_flush_routes_with_iface
+ *
+ * Flush all routes associated with a network device
+ *
+ */
+void nm_system_device_flush_routes_with_iface (const char *iface)
+{
+	char    *buf;
+
+	g_return_if_fail (iface != NULL);
+
+	/* Remove routing table entries */
+	buf = g_strdup_printf (IP_BINARY_PATH" route flush dev %s", iface);
+	nm_spawn_process (buf);
+	g_free (buf);
+}
+
+/*
+ * nm_system_device_flush_addresses
+ *
+ * Flush all network addresses associated with a network device
+ *
+ */
+void nm_system_device_flush_addresses (NMDevice *dev)
+{
+	g_return_if_fail (dev != NULL);
+
+	/* Not really applicable for test devices */
+	if (nm_device_is_test_device (dev))
+		return;
+	nm_system_device_flush_addresses_with_iface (nm_device_get_iface (dev));
+}
+
+/*
+ *  nm_system_device_flush_addresses_with_iface
+ *
+ *  Flush all network addresses associated with a network device
+ *
+ */
+void nm_system_device_flush_addresses_with_iface (const char *iface)
+{
+	char    *buf;
+
+	g_return_if_fail (iface != NULL);
+
+	/* Remove all IP addresses for a device */
+	buf = g_strdup_printf (IP_BINARY_PATH" addr flush dev %s", iface);
+	nm_spawn_process (buf);
+	g_free (buf);
+}
+
+typedef struct PLDSystemConfigData
+{
+	NMIP4Config	*config;
+	gboolean	use_dhcp;
+} PLDSystemConfigData;
+
+/*
+ * set_ip4_config_from_resolv_conf
+ *
+ * Add nameservers and search names from a resolv.conf format file.
+ *
+ */
+static void set_ip4_config_from_resolv_conf (const char *filename, NMIP4Config *ip4_config)
+{
+	char *contents = NULL;
+	char **split_contents = NULL;
+	int i, len;
+
+	g_return_if_fail (filename != NULL);
+	g_return_if_fail (ip4_config != NULL);
+
+	if (!g_file_get_contents (filename, &contents, NULL, NULL) || (contents == NULL))
+		return;
+
+	if (!(split_contents = g_strsplit (contents, "\n", 0)))
+		goto out;
+
+	len = g_strv_length (split_contents);
+	for (i = 0; i < len; i++)
+	{
+		char *line = split_contents[i];
+
+		/* Ignore comments */
+		if (!line || (line[0] == ';') || (line[0] == '#'))
+			continue;
+
+		line = g_strstrip (line);
+		if ((strncmp (line, "search", 6) == 0) && (strlen (line) > 6))
+		{
+			char *searches = g_strdup (line + 7);
+			char **split_searches = NULL;
+
+			if (!searches || !strlen (searches))
+				continue;
+
+			/* Allow space-separated search domains */
+			if ((split_searches = g_strsplit (searches, " ", 0)))
+			{
+				int m, srch_len;
+
+				srch_len = g_strv_length (split_searches);
+				for (m = 0; m < srch_len; m++)
+				{
+					if (split_searches[m])
+						nm_ip4_config_add_domain	(ip4_config, split_searches[m]);
+				}
+				g_strfreev (split_searches);
+			}
+			else
+			{
+				/* Only 1 item, add the whole line */
+				nm_ip4_config_add_domain	(ip4_config, searches);
+			}
+
+			g_free (searches);
+		}
+		else if ((strncmp (line, "nameserver", 10) == 0) && (strlen (line) > 10))
+		{
+			guint32 addr = (guint32) (inet_addr (line + 11));
+
+			if (addr != (guint32) -1)
+				nm_ip4_config_add_nameserver (ip4_config, addr);
+		}
+	}
+
+	g_strfreev (split_contents);
+
+out:
+	g_free (contents);
+}
+
+/*
+ * nm_system_device_get_system_config
+ *
+ * Retrieve any relevant configuration info for a particular device
+ * from the system network configuration information.  Clear out existing
+ * info before setting stuff too.
+ *
+ */
+void *nm_system_device_get_system_config (NMDevice *dev, NMData *app_data)
+{
+	char			*cfg_file_path = NULL;
+	shvarFile		*file, *gateway_file;
+	char			*buf = NULL;
+	int			i, ip[4], prefix;
+	PLDSystemConfigData	*sys_data = NULL;
+	gboolean		error = FALSE;
+
+	g_return_val_if_fail (dev != NULL, NULL);
+
+	/* PLD stores this information in
+	 * /etc/sysconfig/interfaces/ifcfg-* where * is the interface
+	 * name.
+	 */
+
+	sys_data = g_malloc0 (sizeof (PLDSystemConfigData));
+	sys_data->use_dhcp = TRUE;
+
+	cfg_file_path = g_strdup_printf (SYSCONFDIR"/sysconfig/interfaces/ifcfg-%s", nm_device_get_iface (dev));
+	if (!cfg_file_path)
+		return sys_data;
+
+	if (!(file = svNewFile (cfg_file_path)))
+	{
+		g_free (cfg_file_path);
+		return sys_data;
+	}
+	g_free (cfg_file_path);
+
+	/* Make sure this config file is for this device */
+	buf = svGetValue (file, "DEVICE");
+	if (!buf || strcmp (buf, nm_device_get_iface (dev)))
+	{
+		free (buf);
+		goto out;
+	}
+
+	if ((buf = svGetValue (file, "BOOTPROTO")))
+	{
+		if (strcasecmp (buf, "dhcp"))
+			sys_data->use_dhcp = FALSE;
+		free (buf);
+	}
+
+	sys_data->config = nm_ip4_config_new ();
+
+	if (!(sys_data->use_dhcp))
+	{
+		if ((buf = svGetValue (file, "IPADDR")))
+		{
+			sscanf (buf, "%d.%d.%d.%d/%d", &ip[0], &ip[1], &ip[2], &ip[3], &prefix); 
+			sprintf (buf, "%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3]);
+			nm_ip4_config_set_address (sys_data->config, inet_addr (buf));
+			
+			if (prefix >= 0 && prefix <= 32)
+			{
+				for (i = 0; i <= 3; i++)
+				{
+					switch (prefix)
+					{
+						case 7:
+							ip[i] = 254;
+							break;
+						case 6:
+							ip[i] = 252;
+							break;
+						case 5:
+							ip[i] = 248;
+							break;
+						case 4:
+							ip[i] = 240;
+							break;
+						case 3:
+							ip[i] = 224;
+							break;
+						case 2:
+							ip[i] = 192;
+							break;
+						case 1:
+							ip[i] = 128;
+							break;
+						default:
+							if (prefix >= 8)
+							{
+								ip[i] = 255;
+							}
+							else
+							{
+								ip[i] = 0;
+							}
+					}
+					prefix = prefix - 8;
+				}
+				sprintf (buf, "%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3]);
+				nm_ip4_config_set_netmask (sys_data->config, inet_addr (buf));
+				free (buf);
+			}
+			else
+			{
+				nm_warning ("Prefix for device '%s' was invalid (should be between 0 and 32). " 
+						"Try to make default. ", nm_device_get_iface (dev));
+
+				guint32 addr = nm_ip4_config_get_address (sys_data->config);
+
+				if (((ntohl (addr) & 0xFF000000) >> 24) <= 127)
+					nm_ip4_config_set_netmask (sys_data->config, htonl (0xFF000000));
+				else if (((ntohl (addr) & 0xFF000000) >> 24) <= 191)
+					nm_ip4_config_set_netmask (sys_data->config, htonl (0xFFFF0000));
+				else
+				        nm_ip4_config_set_netmask (sys_data->config, htonl (0xFFFFFF00));
+			}
+		}
+		else
+		{
+			nm_warning ("Network configuration for device '%s' was invalid (non-DHCP configuration, "
+						"but no IP address specified.  Will use DHCP instead.", nm_device_get_iface (dev));
+			error = TRUE;
+			goto out;
+		}
+
+		if (gateway_file = svNewFile (SYSCONFDIR"/sysconfig/network"))
+		{
+			buf = svGetValue (gateway_file, "GATEWAYDEV");
+			
+			/* Make sure that GATEWAY is set for this device */
+			if (!buf || strcmp (buf, nm_device_get_iface (dev)))
+			{
+				nm_warning ("Network configuration for device '%s' was invalid (non-DHCP configuration, "
+					    "but no gateway specified - GATEWAYDEV set for other device or unset). Will "
+					    "use DHCP instead.", nm_device_get_iface (dev));
+				
+				free (buf);
+				svCloseFile (gateway_file);
+				error = TRUE;
+				goto out;
+			}
+			
+			if ((buf = svGetValue (gateway_file, "GATEWAY")))
+			{			
+				nm_ip4_config_set_gateway (sys_data->config, inet_addr (buf));
+				free (buf);
+				svCloseFile (gateway_file);
+			}
+			else
+			{
+				nm_warning ("Network configuration for device '%s' was invalid (non-DHCP configuration, "
+						"but no gateway specified.  Will use DHCP instead.", nm_device_get_iface (dev));
+				svCloseFile (gateway_file);
+				error = TRUE;
+				goto out;
+			}
+		}
+
+		if ((buf = svGetValue (file, "BROADCAST")))
+		{
+			nm_ip4_config_set_broadcast (sys_data->config, inet_addr (buf));
+			free (buf);
+		}
+		else
+		{
+			guint32 broadcast = ((nm_ip4_config_get_address (sys_data->config) & nm_ip4_config_get_netmask (sys_data->config))
+									| ~nm_ip4_config_get_netmask (sys_data->config));
+			nm_ip4_config_set_broadcast (sys_data->config, broadcast);
+		}
+	}
+
+	/* If we're using Static IP, grab DNS servers from the config file */
+	if (!sys_data->use_dhcp)
+	{
+		set_ip4_config_from_resolv_conf (SYSCONFDIR"/resolv.conf", sys_data->config);
+	}
+
+out:
+	svCloseFile (file);
+	
+	if (error)
+	{
+		sys_data->use_dhcp = TRUE;
+		/* Clear out the config */
+		nm_ip4_config_unref (sys_data->config);
+		sys_data->config = NULL;
+	}
+
+	return (void *)sys_data;
+}
+
+/*
+ * nm_system_device_has_active_routes
+ *
+ * Find out whether the specified device has any routes in the routing
+ * table.
+ *
+ */
+gboolean nm_system_device_has_active_routes (NMDevice *dev)
+{
+	return FALSE;
+}
+
+/*
+ * nm_system_enable_loopback
+ *
+ * Bring up the loopback interface
+ *
+ */
+void nm_system_enable_loopback (void)
+{
+	nm_system_device_set_up_down_with_iface ("lo", TRUE);
+	nm_spawn_process (IP_BINARY_PATH" addr add 127.0.0.1/8 brd 127.255.255.255 dev lo scope host label loopback");
+}
+
+/*
+ * nm_system_delete_default_route
+ *
+ * Remove the old default route in preparation for a new one
+ *
+ */
+void nm_system_delete_default_route (void)
+{
+	nm_spawn_process (IP_BINARY_PATH" route del default");
+}
+
+/*
+ * nm_system_kill_all_dhcp_daemons
+ *
+ * Kill all DHCP daemons currently running, done at startup.
+ *
+ */
+void nm_system_kill_all_dhcp_daemons (void)
+{
+	nm_spawn_process ("/bin/killall -q dhclient");
+}
+
+/*
+ * nm_system_update_dns
+ *
+ * Make glibc/nscd aware of any changes to the resolv.conf file by
+ * restarting nscd.
+ *
+ */
+void nm_system_update_dns (void)
+{
+	/* I'm not running nscd */
+}
+
+/*
+ * nm_system_restart_mdns_responder
+ *
+ * Restart the multicast DNS responder so that it knows about new
+ * network interfaces and IP addresses.
+ *
+ */
+void nm_system_restart_mdns_responder (void)
+{
+	/* not implemented */
+}
+
+/*
+ * nm_system_device_add_ip6_link_address
+ *
+ * Add a default link-local IPv6 address to a device.
+ *
+ */
+void nm_system_device_add_ip6_link_address (NMDevice *dev)
+{
+	char *buf;
+	struct ether_addr hw_addr;
+	unsigned char eui[8];
+
+	nm_device_get_hw_address (dev, &hw_addr);
+	memcpy (eui, &(hw_addr.ether_addr_octet), sizeof (hw_addr.ether_addr_octet));
+	memmove (eui+5, eui+3, 3);
+	eui[3] = 0xff;
+	eui[4] = 0xfe;
+	eui[0] ^= 2;
+
+	/* Add the default link-local IPv6 address to a device */
+	buf = g_strdup_printf (IP_BINARY_PATH" -6 addr add fe80::%x%02x:%x%02x:%x%02x:%x%02x/64 dev %s",
+					eui[0], eui[1], eui[2], eui[3], eui[4], eui[5],
+					eui[6], eui[7], nm_device_get_iface (dev));
+	nm_spawn_process (buf);
+	g_free (buf);
+}
+
+/*
+ * nm_system_device_add_route_via_device_with_iface
+ *
+ * Add route to the given device
+ *
+ */
+void nm_system_device_add_route_via_device_with_iface (const char *iface, const char *route)
+{
+	char    *buf;
+
+	g_return_if_fail (iface != NULL);
+
+	/* Add default gateway */
+	buf = g_strdup_printf (IP_BINARY_PATH" route add %s dev %s", route, iface);
+	nm_spawn_process (buf);
+	g_free (buf);
+}
+
+/*
+ * nm_system_device_add_default_route_via_device
+ *
+ * Flush all routes associated with a network device
+ *
+ */
+void nm_system_device_add_default_route_via_device (NMDevice *dev)
+{
+	g_return_if_fail (dev != NULL);
+
+	/* Not really applicable for test devices */
+	if (nm_device_is_test_device (dev))
+		return;
+
+	nm_system_device_add_default_route_via_device_with_iface (nm_device_get_iface (dev));
+}
+
+/*
+ *  * nm_system_device_add_default_route_via_device_with_iface
+ *   *
+ *    * Add default route to the given device
+ *     *
+ *      */
+void nm_system_device_add_default_route_via_device_with_iface (const char *iface)
+{
+	char    *buf;
+
+	g_return_if_fail (iface != NULL);
+
+	/* Add default gateway */
+	buf = g_strdup_printf (IP_BINARY_PATH" route add default dev %s", iface);
+	nm_spawn_process (buf);
+	g_free (buf);
+}
+
+/*
+ * nm_system_flush_loopback_routes
+ *
+ * Flush all routes associated with the loopback device, because it
+ * sometimes gets the first route for ZeroConf/Link-Local traffic.
+ *
+ */
+void nm_system_flush_loopback_routes (void)
+{
+	/* Remove routing table entries for lo */
+	nm_spawn_process (IP_BINARY_PATH" route flush dev lo");
+}
+
+/*
+ * nm_system_flush_arp_cache
+ *
+ * Flush all entries in the arp cache.
+ *
+ */
+void nm_system_flush_arp_cache (void)
+{
+	nm_spawn_process (IP_BINARY_PATH" neigh flush all");
+}
+
+void nm_system_deactivate_all_dialup (GSList *list)
+{
+}
+
+gboolean nm_system_deactivate_dialup (GSList *list, const char *dialup)
+{
+	return FALSE;
+}
+
+gboolean nm_system_activate_dialup (GSList *list, const char *dialup)
+{
+	return FALSE;
+}
+
+/*
+ * nm_system_get_dialup_config
+ *
+ * Enumerate dial up options on this system, allocate NMDialUpConfig's,
+ * fill them out, and return.
+ *
+ */
+GSList * nm_system_get_dialup_config (void)
+{
+	return NULL;
+}
+
+void nm_system_device_free_system_config (NMDevice *dev, void *system_config_data)
+{
+	PLDSystemConfigData *sys_data = (PLDSystemConfigData *)system_config_data;
+	
+	g_return_if_fail (dev != NULL);
+	    
+	if (!sys_data)
+		return;
+	
+	if (sys_data->config)
+		nm_ip4_config_unref (sys_data->config);
+}
+
+NMIP4Config *nm_system_device_new_ip4_system_config (NMDevice *dev)
+{
+	PLDSystemConfigData	*sys_data;
+	NMIP4Config		*new_config = NULL;
+	    
+	g_return_val_if_fail (dev != NULL, NULL);
+		
+	if ((sys_data = nm_device_get_system_config_data (dev)))
+		new_config = nm_ip4_config_copy (sys_data->config);
+			    
+	return new_config;
+}
+
+gboolean nm_system_device_get_use_dhcp (NMDevice *dev)
+{
+	PLDSystemConfigData	*sys_data;
+	
+	g_return_val_if_fail (dev != NULL, TRUE);
+	
+	if ((sys_data = nm_device_get_system_config_data (dev)))
+		return sys_data->use_dhcp;
+		    
+	return TRUE;
+}
+
+/*
+ * nm_system_device_get_disabled
+ *
+ * Return whether the distro-specific system config tells us to use
+ * dhcp for this device.
+ *
+ */
+gboolean nm_system_device_get_disabled (NMDevice *dev)
+{
+	return FALSE;
+}
+
+/*
+ * nm_system_activate_nis
+ *
+ * set up the nis domain and write a yp.conf
+ *
+ */
+void nm_system_activate_nis (NMIP4Config *config)
+{
+}
+
+/*
+ * nm_system_shutdown_nis
+ *
+ * shutdown ypbind
+ *
+ */
+void nm_system_shutdown_nis (void)
+{
+}
+
+/*
+ * nm_system_set_hostname
+ *
+ * set the hostname
+ *
+ */
+void nm_system_set_hostname (NMIP4Config *config)
+{
+}
+
+/*
+ * nm_system_should_modify_resolv_conf
+ *
+ * Can NM update resolv.conf, or is it locked down?
+ */
+gboolean nm_system_should_modify_resolv_conf (void)
+{
+	return TRUE;
+}
+
+
+/*
+ * nm_system_get_mtu
+ *
+ * Return a user-provided or system-mandated MTU for this device or zero if
+ * no such MTU is provided.
+ */
+unsigned int nm_system_get_mtu (NMDevice *dev)
+{
+	return 0;
+}
diff -urN NetworkManager-0.6.5.orig/src/backends/NetworkManagerRedHat.c NetworkManager-0.6.5/src/backends/NetworkManagerRedHat.c
--- NetworkManager-0.6.5.orig/src/backends/NetworkManagerRedHat.c	2007-07-23 19:44:13.000000000 +0200
+++ NetworkManager-0.6.5/src/backends/NetworkManagerRedHat.c	2007-10-29 21:43:12.000000000 +0100
@@ -927,7 +927,7 @@
  */
 gboolean nm_system_should_modify_resolv_conf (void)
 {
-	return TRUE;
+	return FALSE;
 }
 
 
