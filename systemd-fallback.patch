--- NetworkManager-1.0.0/configure.ac.orig	2014-12-19 23:27:36.133692361 +0100
+++ NetworkManager-1.0.0/configure.ac	2014-12-19 23:29:57.159595024 +0100
@@ -348,7 +348,7 @@ AM_CONDITIONAL(SESSION_TRACKING_CK, test
 AM_CONDITIONAL(SESSION_TRACKING_SYSTEMD, test "$with_session_tracking" = "systemd")
 if test "$with_session_tracking" = "systemd"; then
 	PKG_CHECK_MODULES(SYSTEMD_LOGIN, [libsystemd],,
-	                  [PKG_CHECK_MODULES(SYSTEMD_LOGIN, [libsystemd-login])])
+	                  [PKG_CHECK_MODULES(SYSTEMD_LOGIN, [libsystemd-daemon libsystemd-login])])
 	AC_SUBST(SYSTEMD_LOGIN_CFLAGS)
 	AC_SUBST(SYSTEMD_LOGIN_LIBS)
 fi
--- NetworkManager-1.0.0/src/nm-session-monitor-systemd.c.orig	2014-12-11 22:28:51.000000000 +0100
+++ NetworkManager-1.0.0/src/nm-session-monitor-systemd.c	2014-12-21 11:30:09.859311469 +0100
@@ -29,10 +29,14 @@
 #include <glib/gstdio.h>
 #include <systemd/sd-login.h>
 #include <stdlib.h>
+#include <systemd/sd-daemon.h>
+#include <sys/stat.h>
+#include <gio/gio.h>
 
 #include "nm-session-utils.h"
 #include "nm-session-monitor.h"
 #include "nm-logging.h"
+#include "nm-errors.h"
 
 /********************************************************************/
 
@@ -109,10 +113,18 @@ sd_source_new (void)
 	return source;
 }
 
+#define CKDB_PATH "/var/run/ConsoleKit/database"
+
 struct _NMSessionMonitor {
 	GObject parent_instance;
 
 	GSource *sd_source;
+
+	GKeyFile *database;
+	GFileMonitor *database_monitor;
+	time_t database_mtime;
+	GHashTable *sessions_by_uid;
+	GHashTable *sessions_by_user;
 };
 
 struct _NMSessionMonitorClass {
@@ -132,6 +144,215 @@ G_DEFINE_TYPE (NMSessionMonitor, nm_sess
 
 /* ---------------------------------------------------------------------------------------------------- */
 
+typedef struct {
+	char *user;
+	uid_t uid;
+	gboolean local;
+	gboolean active;
+} Session;
+
+static void
+session_free (Session *s)
+{
+	g_free (s->user);
+	memset (s, 0, sizeof (Session));
+	g_free (s);
+}
+
+static gboolean
+check_key (GKeyFile *keyfile, const char *group, const char *key, GError **error)
+{
+	if (g_key_file_has_key (keyfile, group, key, error))
+		return TRUE;
+
+	if (!error) {
+		g_set_error (error,
+			         NM_MANAGER_ERROR,
+			         NM_MANAGER_ERROR_FAILED,
+			         "ConsoleKit database " CKDB_PATH " group '%s' had no '%s' key",
+			         group, key);
+	}
+	return FALSE;
+}
+
+static Session *
+session_new (GKeyFile *keyfile, const char *group, GError **error)
+{
+	GError *local = NULL;
+	Session *s;
+	const char *uname = NULL;
+
+	s = g_new0 (Session, 1);
+	g_assert (s);
+
+	s->uid = G_MAXUINT; /* paranoia */
+	if (!check_key (keyfile, group, "uid", &local))
+		goto error;
+	s->uid = (uid_t) g_key_file_get_integer (keyfile, group, "uid", &local);
+	if (local)
+		goto error;
+
+	if (!check_key (keyfile, group, "is_active", &local))
+		goto error;
+	s->active = g_key_file_get_boolean (keyfile, group, "is_active", &local);
+	if (local)
+		goto error;
+
+	if (!check_key (keyfile, group, "is_local", &local))
+		goto error;
+	s->local = g_key_file_get_boolean (keyfile, group, "is_local", &local);
+	if (local)
+		goto error;
+
+	if (!nm_session_uid_to_user (s->uid, &uname, error))
+		return FALSE;
+	s->user = g_strdup (uname);
+
+	return s;
+
+error:
+	session_free (s);
+	g_propagate_error (error, local);
+	return NULL;
+}
+
+static void
+session_merge (Session *src, Session *dest)
+{
+	g_return_if_fail (src != NULL);
+	g_return_if_fail (dest != NULL);
+
+	g_warn_if_fail (g_strcmp0 (src->user, dest->user) == 0);
+	g_warn_if_fail (src->uid == dest->uid);
+
+	dest->local = (dest->local || src->local);
+	dest->active = (dest->active || src->active);
+}
+
+/********************************************************************/
+
+static void
+free_database (NMSessionMonitor *self)
+{
+	if (self->database != NULL) {
+		g_key_file_free (self->database);
+		self->database = NULL;
+	}
+
+	g_hash_table_remove_all (self->sessions_by_uid);
+	g_hash_table_remove_all (self->sessions_by_user);
+}
+
+static gboolean
+reload_database (NMSessionMonitor *self, GError **error)
+{
+	struct stat statbuf;
+	char **groups = NULL;
+	gsize len = 0, i;
+	Session *s;
+
+	free_database (self);
+
+	errno = 0;
+	if (stat (CKDB_PATH, &statbuf) != 0) {
+		g_set_error (error,
+		             NM_MANAGER_ERROR,
+		             NM_MANAGER_ERROR_FAILED,
+		             "Error statting file " CKDB_PATH ": %s",
+		             strerror (errno));
+		goto error;
+	}
+	self->database_mtime = statbuf.st_mtime;
+
+	self->database = g_key_file_new ();
+	if (!g_key_file_load_from_file (self->database, CKDB_PATH, G_KEY_FILE_NONE, error))
+		goto error;
+
+	groups = g_key_file_get_groups (self->database, &len);
+	if (!groups) {
+		g_set_error_literal (error,
+		                     NM_MANAGER_ERROR,
+		                     NM_MANAGER_ERROR_FAILED,
+		                     "Could not load groups from " CKDB_PATH "");
+		goto error;
+	}
+
+	for (i = 0; i < len; i++) {
+		Session *found;
+
+		if (!g_str_has_prefix (groups[i], "Session "))
+			continue;
+
+		s = session_new (self->database, groups[i], error);
+		if (!s)
+			goto error;
+
+		found = g_hash_table_lookup (self->sessions_by_user, (gpointer) s->user);
+		if (found) {
+			session_merge (s, found);
+			session_free (s);
+		} else {
+			/* Entirely new user */
+			g_hash_table_insert (self->sessions_by_user, (gpointer) s->user, s);
+			g_hash_table_insert (self->sessions_by_uid, GUINT_TO_POINTER (s->uid), s);
+		}
+	}
+
+	g_strfreev (groups);
+	return TRUE;
+
+error:
+	if (groups)
+		g_strfreev (groups);
+	free_database (self);
+	return FALSE;
+}
+
+static gboolean
+ensure_database (NMSessionMonitor *self, GError **error)
+{
+	gboolean ret = FALSE;
+
+	if (self->database != NULL) {
+		struct stat statbuf;
+
+		errno = 0;
+		if (stat (CKDB_PATH, &statbuf) != 0) {
+			g_set_error (error,
+			             NM_MANAGER_ERROR,
+			             NM_MANAGER_ERROR_FAILED,
+			             "Error statting file " CKDB_PATH " to check timestamp: %s",
+			             strerror (errno));
+			goto out;
+		}
+
+		if (statbuf.st_mtime == self->database_mtime) {
+			ret = TRUE;
+			goto out;
+		}
+	}
+
+	ret = reload_database (self, error);
+
+out:
+	return ret;
+}
+
+static void
+on_file_monitor_changed (GFileMonitor *    file_monitor,
+                         GFile *           file,
+                         GFile *           other_file,
+                         GFileMonitorEvent event_type,
+                         gpointer          user_data)
+{
+	NMSessionMonitor *self = NM_SESSION_MONITOR (user_data);
+
+	/* throw away cache */
+	free_database (self);
+
+	g_signal_emit (self, signals[CHANGED_SIGNAL], 0);
+}
+
 static gboolean
 sessions_changed (gpointer user_data)
 {
@@ -145,9 +366,46 @@ sessions_changed (gpointer user_data)
 static void
 nm_session_monitor_init (NMSessionMonitor *monitor)
 {
-	monitor->sd_source = sd_source_new ();
-	g_source_set_callback (monitor->sd_source, sessions_changed, monitor, NULL);
-	g_source_attach (monitor->sd_source, NULL);
+	if (sd_booted () > 0) {
+		monitor->sd_source = sd_source_new ();
+		g_source_set_callback (monitor->sd_source, sessions_changed, monitor, NULL);
+		g_source_attach (monitor->sd_source, NULL);
+
+		monitor->database_monitor = NULL;
+		monitor->database = NULL;
+	} else {
+		GError *error = NULL;
+		GFile *file;
+
+		monitor->sd_source = NULL;
+
+		/* Sessions-by-user is responsible for destroying the Session objects */
+		monitor->sessions_by_user = g_hash_table_new_full (g_str_hash, g_str_equal,
+			                                            NULL, (GDestroyNotify) session_free);
+		monitor->sessions_by_uid = g_hash_table_new (g_direct_hash, g_direct_equal);
+
+
+		if (!ensure_database (monitor, &error)) {
+			nm_log_dbg (LOGD_CORE, "Error loading " CKDB_PATH ": %s", error->message);
+
+			/* Ignore the first error, the CK database might not exist yet */
+			g_error_free (error);
+			error = NULL;
+		}
+
+		file = g_file_new_for_path (CKDB_PATH);
+		monitor->database_monitor = g_file_monitor_file (file, G_FILE_MONITOR_NONE, NULL, &error);
+		g_object_unref (file);
+		if (monitor->database_monitor == NULL) {
+			nm_log_err (LOGD_CORE, "Error monitoring " CKDB_PATH ": %s", error->message);
+			g_error_free (error);
+		} else {
+			g_signal_connect (monitor->database_monitor,
+				              "changed",
+				              G_CALLBACK (on_file_monitor_changed),
+				              monitor);
+		}
+	}
 }
 
 static void
@@ -155,11 +413,19 @@ nm_session_monitor_finalize (GObject *ob
 {
 	NMSessionMonitor *monitor = NM_SESSION_MONITOR (object);
 
-	if (monitor->sd_source != NULL) {
-		g_source_destroy (monitor->sd_source);
-		g_source_unref (monitor->sd_source);
+	if (sd_booted () > 0) {
+		if (monitor->sd_source != NULL) {
+			g_source_destroy (monitor->sd_source);
+			g_source_unref (monitor->sd_source);
+		}
+	} else {
+		if (monitor->database_monitor != NULL)
+			g_object_unref (monitor->database_monitor);
+
+		free_database (monitor);
 	}
 
+
 	if (G_OBJECT_CLASS (nm_session_monitor_parent_class)->finalize != NULL)
 		G_OBJECT_CLASS (nm_session_monitor_parent_class)->finalize (object);
 }
@@ -205,15 +471,36 @@ nm_session_monitor_user_has_session (NMS
                                      uid_t *out_uid,
                                      GError **error)
 {
-	uid_t uid;
+	if (sd_booted () > 0) {
+		uid_t uid;
 
-	if (!nm_session_user_to_uid (username, &uid, error))
-		return FALSE;
+		if (!nm_session_user_to_uid (username, &uid, error))
+			return FALSE;
 
-	if (out_uid)
-		*out_uid = uid;
+		if (out_uid)
+			*out_uid = uid;
 
-	return nm_session_monitor_uid_has_session (monitor, uid, NULL, error);
+		return nm_session_monitor_uid_has_session (monitor, uid, NULL, error);
+	} else {
+		Session *s;
+
+		if (!ensure_database (monitor, error))
+			return FALSE;
+
+		s = g_hash_table_lookup (monitor->sessions_by_user, (gpointer) username);
+		if (!s) {
+			g_set_error (error,
+				         NM_MANAGER_ERROR,
+				         NM_MANAGER_ERROR_FAILED,
+				         "No session found for user '%s'",
+				         username);
+			return FALSE;
+		}
+
+		if (out_uid)
+			*out_uid = s->uid;
+		return TRUE;
+	}
 }
 
 gboolean
@@ -221,12 +508,31 @@ nm_session_monitor_user_active (NMSessio
                                 const char *username,
                                 GError **error)
 {
-	uid_t uid;
+	if (sd_booted () > 0) {
+		uid_t uid;
 
-	if (!nm_session_user_to_uid (username, &uid, error))
-		return FALSE;
+		if (!nm_session_user_to_uid (username, &uid, error))
+			return FALSE;
+
+		return nm_session_monitor_uid_active (monitor, uid, error);
+	} else {
+		Session *s;
+
+		if (!ensure_database (monitor, error))
+			return FALSE;
+
+		s = g_hash_table_lookup (monitor->sessions_by_user, (gpointer) username);
+		if (!s) {
+			g_set_error (error,
+				         NM_MANAGER_ERROR,
+				         NM_MANAGER_ERROR_FAILED,
+				         "No session found for user '%s'",
+				         username);
+			return FALSE;
+		}
 
-	return nm_session_monitor_uid_active (monitor, uid, error);
+		return s->active;
+	}
 }
 
 gboolean
@@ -235,19 +541,40 @@ nm_session_monitor_uid_has_session (NMSe
                                     const char **out_user,
                                     GError **error)
 {
-	int num_sessions;
+	if (sd_booted () > 0) {
+		int num_sessions;
 
-	if (!nm_session_uid_to_user (uid, out_user, error))
-		return FALSE;
+		if (!nm_session_uid_to_user (uid, out_user, error))
+			return FALSE;
 
-	/* Get all sessions (including inactive ones) for the user */
-	num_sessions = sd_uid_get_sessions (uid, 0, NULL);
-	if (num_sessions < 0) {
-		nm_log_warn (LOGD_CORE, "Failed to get systemd sessions for uid %d: %d",
-		             uid, num_sessions);
-		return FALSE;
+		/* Get all sessions (including inactive ones) for the user */
+		num_sessions = sd_uid_get_sessions (uid, 0, NULL);
+		if (num_sessions < 0) {
+			nm_log_warn (LOGD_CORE, "Failed to get systemd sessions for uid %d: %d",
+				         uid, num_sessions);
+			return FALSE;
+		}
+		return num_sessions > 0;
+	} else {
+		Session *s;
+
+		if (!ensure_database (monitor, error))
+			return FALSE;
+
+		s = g_hash_table_lookup (monitor->sessions_by_uid, GUINT_TO_POINTER (uid));
+		if (!s) {
+			g_set_error (error,
+				         NM_MANAGER_ERROR,
+				         NM_MANAGER_ERROR_FAILED,
+				         "No session found for uid %d",
+				         uid);
+			return FALSE;
+		}
+
+		if (out_user)
+			*out_user = s->user;
+		return TRUE;
 	}
-	return num_sessions > 0;
 }
 
 gboolean
@@ -255,14 +582,33 @@ nm_session_monitor_uid_active (NMSession
                                uid_t uid,
                                GError **error)
 {
-	int num_sessions;
+	if (sd_booted () > 0) {
+		int num_sessions;
 
-	/* Get active sessions for the user */
-	num_sessions = sd_uid_get_sessions (uid, 1, NULL);
-	if (num_sessions < 0) {
-		nm_log_warn (LOGD_CORE, "Failed to get active systemd sessions for uid %d: %d",
-		             uid, num_sessions);
-		return FALSE;
+		/* Get active sessions for the user */
+		num_sessions = sd_uid_get_sessions (uid, 1, NULL);
+		if (num_sessions < 0) {
+			nm_log_warn (LOGD_CORE, "Failed to get active systemd sessions for uid %d: %d",
+				         uid, num_sessions);
+			return FALSE;
+		}
+		return num_sessions > 0;
+	} else {
+		Session *s;
+
+		if (!ensure_database (monitor, error))
+			return FALSE;
+
+		s = g_hash_table_lookup (monitor->sessions_by_uid, GUINT_TO_POINTER (uid));
+		if (!s) {
+			g_set_error (error,
+				         NM_MANAGER_ERROR,
+				         NM_MANAGER_ERROR_FAILED,
+				         "No session found for uid '%d'",
+				         uid);
+			return FALSE;
+		}
+
+		return s->active;
 	}
-	return num_sessions > 0;
 }
--- NetworkManager-1.0.0/src/nm-sleep-monitor-systemd.c.orig	2014-12-19 23:32:53.481973137 +0100
+++ NetworkManager-1.0.0/src/nm-sleep-monitor-systemd.c	2014-12-20 00:12:04.572281013 +0100
@@ -35,12 +35,15 @@
 #define SD_PATH              "/org/freedesktop/login1"
 #define SD_INTERFACE         "org.freedesktop.login1.Manager"
 
+#define UPOWER_DBUS_SERVICE "org.freedesktop.UPower"
 
 struct _NMSleepMonitor {
 	GObject parent_instance;
 
 	GDBusProxy *sd_proxy;
 	gint inhibit_fd;
+
+	DBusGProxy *upower_proxy;
 };
 
 struct _NMSleepMonitorClass {
@@ -62,6 +65,20 @@ G_DEFINE_TYPE (NMSleepMonitor, nm_sleep_
 
 /********************************************************************/
 
+static void
+upower_sleeping_cb (DBusGProxy *proxy, gpointer user_data)
+{
+        nm_log_dbg (LOGD_SUSPEND, "Received UPower sleeping signal");
+        g_signal_emit (user_data, signals[SLEEPING], 0);
+}
+
+static void
+upower_resuming_cb (DBusGProxy *proxy, gpointer user_data)
+{
+        nm_log_dbg (LOGD_SUSPEND, "Received UPower resuming signal");
+        g_signal_emit (user_data, signals[RESUMING], 0);
+}
+
 static gboolean
 drop_inhibitor (NMSleepMonitor *self)
 {
@@ -193,14 +210,37 @@ on_proxy_acquired (GObject *object,
 static void
 nm_sleep_monitor_init (NMSleepMonitor *self)
 {
-	self->inhibit_fd = -1;
-	g_dbus_proxy_new_for_bus (G_BUS_TYPE_SYSTEM,
-	                          G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START |
-	                          G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES,
-	                          NULL,
-	                          SD_NAME, SD_PATH, SD_INTERFACE,
-	                          NULL,
-	                          (GAsyncReadyCallback) on_proxy_acquired, self);
+	if (sd_booted () > 0) {
+		self->inhibit_fd = -1;
+		g_dbus_proxy_new_for_bus (G_BUS_TYPE_SYSTEM,
+			                      G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START |
+			                      G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES,
+			                      NULL,
+			                      SD_NAME, SD_PATH, SD_INTERFACE,
+			                      NULL,
+			                      (GAsyncReadyCallback) on_proxy_acquired, self);
+	} else {
+		DBusGConnection *bus;
+
+        bus = nm_dbus_manager_get_connection (nm_dbus_manager_get ());
+        self->upower_proxy = dbus_g_proxy_new_for_name (bus,
+                                                        UPOWER_DBUS_SERVICE,
+                                                        "/org/freedesktop/UPower",
+                                                        "org.freedesktop.UPower");
+        if (self->upower_proxy) {
+            dbus_g_proxy_add_signal (self->upower_proxy, "Sleeping", G_TYPE_INVALID);
+            dbus_g_proxy_connect_signal (self->upower_proxy, "Sleeping",
+                                         G_CALLBACK (upower_sleeping_cb),
+                                         self, NULL);
+
+            dbus_g_proxy_add_signal (self->upower_proxy, "Resuming", G_TYPE_INVALID);
+            dbus_g_proxy_connect_signal (self->upower_proxy, "Resuming",
+                                         G_CALLBACK (upower_resuming_cb),
+                                         self, NULL);
+        } else {
+    		nm_log_warn (LOGD_SUSPEND, "could not initialize UPower D-Bus proxy");
+		}
+	}
 }
 
 static void
@@ -208,9 +248,14 @@ finalize (GObject *object)
 {
 	NMSleepMonitor *self = NM_SLEEP_MONITOR (object);
 
-	drop_inhibitor (self);
-	if (self->sd_proxy)
-		g_object_unref (self->sd_proxy);
+	if (sd_booted () > 0) {
+		drop_inhibitor (self);
+		if (self->sd_proxy)
+			g_object_unref (self->sd_proxy);
+	} else {
+		if (self->upower_proxy)
+    		g_object_unref (self->upower_proxy);
+	}
 
 	if (G_OBJECT_CLASS (nm_sleep_monitor_parent_class)->finalize != NULL)
 		G_OBJECT_CLASS (nm_sleep_monitor_parent_class)->finalize (object);
